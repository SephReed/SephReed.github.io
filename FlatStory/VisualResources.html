<script type="text/javascript">


// var Resources, Visuals, ChipMapping;



PINE.waitForNeeds(["Resources", "LogicalResources", "ELATE"], function() {
	Visual = FLAT.Resources.Visual = {};





	//should return a promise to load all needed chipsets and use them to do some painting
	Visual.makeProjectSeeable = function(project) {

		if(project.inheritsFrom("SeeableProject"))
			return SyncPromise.resolved(project);


		else {
			ELATE.evolve(project, "SeeableProject");
			return project.seeableProjectReadyPromise.then(function(){return project});
		}
		

		// if(project.GUI == undefined) {
		// 	var promises = []
		// 	var map = project.currentMap;
		// 	for(var i = 0; i < map.layers.length; i++) {
		// 		var layer = map.layers[i];
		// 		for(var c = 0; c < layer.chipSetNames.length; c++)
		// 			promises.push(Visual.assertChipSet(layer.chipSetNames[i]));
		// 	}

		// 	return SyncPromise.all(promises).then(function(){
		// 		console.log("CHIP SETS LOADED")
		// 		new ProjectGraphics(project);	
		// 	});
			
		// }
		// else 
			
	}




	Visual.assertChipSet = function(filePath) {
		if(Visual.chipSets.byName[filePath])
			return SyncPromise.resolved();

		else return new Promise(function(resolve) {
			// var imgNode = Pal.currentChipset.imgNode = document.createElement("img");
			var imgNode = document.createElement("img");
			imgNode.src = filePath;

			imgNode.addEventListener("load", function() {
				var name = filePath.match(/[^\/]+$/g);

				var chipSet = new ChipSet({
					name: name,
					imgNode: imgNode
				});

				Visual.chipSets.current = chipSet;
				resolve(chipSet);
			});
			
		});
	}


	Visual.chipSets = {};
	Visual.chipSets.current = undefined;
	Visual.chipSets.lastID = 0;
	Visual.chipSets.byID = [];
	Visual.chipSets.byName = {};




	/**************************
	*
	*		CLASSES
	*
	***************************/




	Visual.class = {};





	/**************************
	*		Graphics
	***************************/

	// ProjectGraphics = Visual.class.ProjectGraphics = function(project) {
	// 	this.project = project;
	// 	project.GUI = this;
	// 	this.mapGraphics = {};
	// 	this.mapGraphics[project.currentMap] = new MapGraphics(project.currentMap);
	// }

	// MapGraphics = Visual.class.MapGraphics = function(map) {
	// 	this.map = map;
	// 	map.GUI = this;
	// 	this.domNode = document.createElement("map");
	// 	this.layerGraphics = [];

	// 	for(var i = 0; i < map.layers.length; i++) {
	// 		var chipCanvas = new ChipCanvas({chipMap: map.layers[i]});
	// 		this.layerGraphics.push(chipCanvas);

	// 		this.domNode.appendChild(chipCanvas.domNode);
	// 	}
	// }


	ChipSet = Visual.class.ChipSet = ELATE.create("ChipSet", function() {


		this.build = function(args) {
			this.name = args.name;
			this.id = Visual.chipSets.lastID;
			Visual.chipSets.lastID++;
			this.imgNode = args.imgNode;
			this.chipSize = args.chipSize || 16;
			this.chips = [];
			this.zoom = 3;

			this.chipsTall = ~~(this.imgNode.naturalHeight/this.chipSize);
			this.chipsWide = ~~(this.imgNode.naturalWidth/this.chipSize);

			for(var row = 0; row < this.chipsTall; row++) {
				for(var col = 0; col < this.chipsWide; col++) {
					var chip = {};
					chip.num = (row * this.chipsWide) + col;
					chip.row = row;
					chip.col = col;
					chip.imageX = chip.col * this.chipSize;
					chip.imageY = chip.row * this.chipSize;
					this.chips[chip.num] = chip;	
				}
			}

			Visual.chipSets.byID[this.id] = this;
			Visual.chipSets.byName[this.name] = this;

			this.setSelectedChip(0);
		}


		this.setSelectedChip = function(id) {
			this.selectedChip = this.chips[id];
		}


		this.getChip = function(chipID) {
			return this.chips[chipID];
		}

		
	});





	/**************************
	*		Canvases
	***************************/


	// Canvas = Visual.class.Canvas = ELATE.create("Canvas", function() {
	// 		//
	// 	this.build = function(canvasNode) {
	// 		if(canvasNode == undefined) {
	// 			canvasNode = document.createElement("canvas");
	// 		}

	// 		this.domNode = canvasNode;
	// 		this.painter = canvasNode.getContext("2d");
	// 	}

	// 	this.sizeEquals = function(canvas) {
	// 		return this.domNode.width == canvas.width && this.domNode.height == canvas.height;
	// 	}

	// 	this.setSizeEqualTo = function(canvas) {
	// 		this.domNode.width = canvas.width;
	// 		this.domNode.height = canvas.height;
	// 	}
	// });








	/***************************************
	*		Logical Resource Evolutions
	****************************************/

	Visual.evolves = {};
	Visual.evolves.hasCanvas = ELATE.create("hasCanvas", function() {
		this.canEvolve("*");

		this.evolveThis = function() {
			this.domNode = document.createElement("canvas");
			this.painter = this.domNode.getContext("2d");
		}

		this.canvasSizeEquals = function(canvas) {
			return this.domNode.width == canvas.width && this.domNode.height == canvas.height;
		}

		this.setCanvasSizeTo = function(width, height) {
			if(this.domNode.width !== width)
				this.domNode.width = width;

			if(this.domNode.height !== height)
				this.domNode.height = height;
			
		}
	});




	ELATE.create("SeeableProject", function() {
		this.evolvesFrom("Project");

		this.evolveThis = function() {
			ELATE.evolve(this.currentMap, "SeeableMap");
			this.seeableProjectReadyPromise = this.currentMap.seeableMapReadyPromise;
		}
	});




	ELATE.create("SeeableMap", function() {
		this.evolvesFrom("FlatMap");

		this.parseArgs = function(mapData) {
			return { FlatMap: mapData }
		}

		this.evolveThis = function() {
			this.domNode = document.createElement("FlatMap");
			
			var promises = []
			for(var i = 0; i < this.layers.length; i++) {
				var layer = this.layers[i];
				ELATE.evolve(layer, "SeeableChipLayer");
				promises.push(layer.seeableChipLayerReadyPromise);
				this.domNode.appendChild(layer.domNode);
			}


			this.seeableMapReadyPromise = SyncPromise.all(promises);
		}

		this.createNewLayer = function(name, chipsWide, chipsTall) {
			var layer = this.super.FlatMap.createNewLayer(name, chipsWide, chipsTall);
			ELATE.evolve(layer, "SeeableChipLayer");

			this.domNode.appendChild(layer.domNode);

			return layer;
		}
	});






	ChipCanvas = Visual.class.ChipCanvas = ELATE.create("SeeableChipLayer", function() {

		this.evolvesFrom("ChipLayer");
		this.implements("hasCanvas")

		this.evolveThis = function() {
			var stales = this.unrenderedChips = "all";

			var promises = [];
			for(var i = 0; i < this.chipSetNames.length; i++) {
				promises.push(Visual.assertChipSet(this.chipSetNames[i]));
			}

			var thisChipLayer = this;
			this.seeableChipLayerReadyPromise = SyncPromise.all(promises).then(function(){thisChipLayer.baseline()});
		}

		this.setChip = function(row, col, value) {
			this.super.ChipLayer.setChip(row, col, value);

			var stales = this.unrenderedChips;
			if(stales != "all") {
				var target = stales.find(function(item){
					return item.row == row && item.col == col;
				});

				if(target == undefined)
					stales.push({row: row, col: col});
			}

			this.updateRender();
		}

		this.setSizeEqualTo = function(canvas) {
			this.super.Canvas.setSizeEqualTo(this, canvas)
			this.unrenderedChips = "all";

			this.baseline();
		}

		this.updateRender = function() {
			if(this.renderUpdateFrameRequest == undefined) {
				var thisChipCanvas = this;

				this.renderUpdateFrameRequest = window.requestAnimationFrame(function() {
					var updates = thisChipCanvas.unrenderedChips;
					if(updates == "all") {
						for(var row = 0; row < thisChipCanvas.chipsTall; row++) {
							for(var col = 0; col < thisChipCanvas.chipsWide; col++) {
								thisChipCanvas.renderChip(row, col)
							}
						}
					}

					else {
						for(var i = 0; i < updates.length; i++) {
							var update = updates[i];
							thisChipCanvas.renderChip(update.row, update.col);
						}
					}

					thisChipCanvas.unrenderedChips = [];
					thisChipCanvas.renderUpdateFrameRequest = undefined;
				});
			}
		}



		this.renderChip = function(row, col) {
			var chipNum = this.getChip(row, col);
			var chipSet = Visual.chipSets.byID[0]; //MAGIC NUMBER
			var size = chipSet.chipSize;
			
			if(chipNum >= 0) {
				var chip = chipSet.getChip(chipNum);

				this.painter.drawImage(chipSet.imgNode, 
					chip.imageX,  chip.imageY, size, size, 
					col*size, row*size, size, size);
			}
			else {
				this.painter.clearRect(col*size, row*size, size, size);
			}
		}


		this.baseline = function() {
			var domNode = this.domNode;

			var chipSet = Visual.chipSets.byID[0];  //MAGIC NUMBER

			var expectedWidth = chipSet.chipSize * this.chipsWide;
			var expectedHeight = chipSet.chipSize * this.chipsTall;
				//
			if(domNode.width != expectedWidth || domNode.height != expectedHeight) {
				domNode.width = expectedHeight;
				domNode.height = expectedHeight
				this.unrenderedChips = "all";
			}

			this.updateRender();
		}




	});





	// ChipCanvas = Visual.class.ChipCanvas = ELATE.create("ChipCanvas", function() {

	// 	this.evolvesFrom("Canvas", "ChipMapping");

	// 	this.build = function(args) {
	// 		this.super.Canvas(this, args.canvasNode);

	// 		var stales = this.unrenderedChips = "all";
	// 		this.chipMap = args.chipMap;

	// 		// var promises = [];
	// 		// for(var i = 0; i < this.chipMap.chipSetNames.length; i++) {
	// 		// 	promises.push(Visual.assertChipSet(this.chipMap.chipSetNames[i]));
	// 		// }

	// 		console.log(this.chipMap);
	// 		this.chipMap.addEventListener("chipChange", function(event){
	// 			if(stales != "all") {

	// 				for(var i = 0; i < stales.length; i++) {
	// 					if(stales[i].row == event.row && stales[i].col == event.col)
	// 						return;
	// 				}

	// 				stales.push({row: event.row, col: event.col});
	// 			}
	// 		});
	// 		this.baseline();
	// 	}

	// 	this.setSizeEqualTo = function(canvas) {
	// 		this.super.Canvas.prototype.setSizeEqualTo.call(this, canvas)
	// 		this.unrenderedChips = "all";

	// 		this.baseline();
	// 	}

	// 	this.updateRender = function() {
	// 		var updates = this.unrenderedChips;

	// 		if(updates == "all") {
	// 			var chipMap = this.chipMap;

	// 			for(var row = 0; row < chipMap.height; row++) {
	// 				for(var col = 0; col < chipMap.width; col++) {
	// 					this.renderChip(row, col)
	// 				}
	// 			}
	// 		}

	// 		else {
	// 			for(var i = 0; i < updates.length; i++) {
	// 				var update = updates[i];
	// 				this.renderChip(update.row, update.col);
	// 			}
	// 		}

	// 		console.log("RENDER UPDATE", this.unrenderedChips);
	// 		this.unrenderedChips = [];
	// 	}

	// 	this.renderChip = function(row, col) {
	// 		var chipNum = this.chipMap.getChip(row, col);
	// 		var chipSet = Visual.chipSets.byID[0];

	// 		var chip = chipSet.getChip(chipNum);
	// 		var size = chipSet.chipSize;

	// 		// var imageData = Pal.getChipImageData(chipNum);
	// 		// out.painter.putImageData(imageData, col*size, row*size);

	// 		this.painter.drawImage(chipSet.imgNode, 
	// 			chip.imageX,  chip.imageY, size, size, 
	// 			col*size, row*size, size, size);
	// 	}

	// 	this.baseline = function() {
	// 		var domNode = this.domNode;

	// 		console.log(this);
	// 		var chipSet = Visual.chipSets.byID[0];

	// 		var expectedWidth = chipSet.chipSize * this.chipMap.width;
	// 		var expectedHeight = chipSet.chipSize * this.chipMap.height;
	// 			//
	// 		if(domNode.width != expectedWidth || domNode.height != expectedHeight) {
	// 			domNode.width = expectedHeight;
	// 			domNode.height = expectedHeight
	// 			this.unrenderedChips = "all";
	// 		}

	// 		this.updateRender();
	// 	}
	// });






	PINE.signalNeedReady("VisualResources");
})




</script>








<style>
	map {
		display: block;
		height: 100%;
		width: 100%;
	}
</style>







