<script type="text/javascript">


// var Resources, Visuals, ChipLayer;

var Logic, ChipLayer;

PINE.waitForNeeds(["Resources", "ELATE"], function() {
	Logic = FLAT.Resources.Logic = {}


	Logic.openProject = function(projectName){

		var projectFile = Resources.projects[projectName];

		if(projectFile != undefined) {
			Resources.currentProject = projectFile;
			return new SyncPromise.resolved(projectFile);
			
		}
		else {
			projectFile = new Logic.class.UnloadedProject(projectName);
			Resources.currentProject = projectFile;

			var filePath = projectFile.pathPrefix + projectName+".flat-project.txt";
			return BRIDGE.loadJSON(filePath).then(function(projectData){
				ELATE.evolve(projectFile, "Project", [null, projectData]);
				return projectFile.projectReadyPromise;
			})
			.then(function(){ return projectFile; });		
		}

	}





	Logic.unpackageMap = function(mapFile) {
		var out = mapFile.split(/\n/g);

		for(var i in out) {
			out[i] = out[i].match(/\S+/g);
		}

		return out;
	}

	Logic.packageMap = function(chips) {
		var printOut = ""
		for(var row = 0; row < height; row++) {
			for(var col = 0; col < width; col++) {
				printOut += chips[row][col] + " ";
			}

			if(row < height-1)
				printOut += "\n";
		}
		return printOut;
	}





	Logic.class = {}


	Logic.class.UnloadedProject = ELATE.create("UnloadedProject", function() {
		this.build = function(projectName) {
			this.pathPrefix = FLAT.BridgePrefix + projectName+"/";
			this.projectName = projectName;
		}
	});


	Project = Logic.class.Project = ELATE.create("Project", function() {
		this.evolvesFrom("UnloadedProject");
		this.implements("Treeable");

		this.parseArgs = function(name, projectData) {
			return {
				UnloadedProject : [name],
				Project: [projectData]
			}
		}

		this.evolveThis = function(projectData) {

			this.super.Treeable(null, "maps");

			var mapPath = projectData.currentMap;
			var mapName = mapPath.match(/[^\/]+$/);
			var mapPath = Resources.currentProject.pathPrefix+"maps/"+mapName+"/"
			mapFilePath = mapPath+mapName+".map-file.txt";

			var thisProject = this;
			this.projectReadyPromise = BRIDGE.loadJSON(mapFilePath)
			.then(function(mapData){ 
				thisProject.currentMap = new FlatMap(mapPath, mapData);
				thisProject.appendChild(thisProject.currentMap);
				return thisProject.currentMap.flatMapReadyPromise;
			});
		}


		// this.addMap = function
	});



	FlatMap = Logic.class.FlatMap = ELATE.create("FlatMap", function() {


		this.implements("EventDispatcher");
		this.implements("Saveable");
		this.implements("Treeable");

		this.build = function(mapPath, mapData) {
			// this.layers = [];

			this.super.Treeable("project", "layers");


			this.chipsWide = mapData.chipsWide;
			this.chipsTall = mapData.chipsTall;
			this.mapPath = mapPath;
			this.width = this.chipsWide * 16;  //TODO magic number, and move chipwidth to layers
			this.height = this.chipsTall * 16;

			var layerPromises = [];
			var thisMap = this;

			for(var i = 0; i < mapData.layers.length; i++) {
				var layerName = mapData.layers[i];
				var layerPath = this.mapPath+layerName+".chip-layer.txt";

				var promise = BRIDGE.loadFile(layerPath)
				.then(function(request){
					var addMe = new ChipLayer(null, null, request.response);
					thisMap.addLayer(addMe);
					thisMap.repeatDispatches(addMe);
				});

				layerPromises.push(promise);
			}




			this.flatMapReadyPromise = SyncPromise.all(layerPromises).then(function(){
				thisMap.currentLayer = thisMap.layers[mapData.currentLayer || 0];
			});

			return {Saveable: [mapPath, true]};
		}

		this.addLayer = function(layer) {
			// if(layer.map != this)

			if(this.appendChild(layer))
				this.repeatDispatches(layer);
			
		}


		this.createNewLayer = function(name, chipsWide, chipsTall) {
			var addMe = new ChipLayer(chipsWide || 16, chipsTall || 16);
			this.addLayer(addMe);
			this.markUnsaved();

			return addMe;
		}


		this.setCurrentLayer = function(layer) {
			if(this.layers.indexOf(layer) == -1)
				PINE.err("Can not set current layer to layer from another map");

			else if (this.currentLayer != layer){
				var old = this.currentLayer;
				this.currentLayer = layer;	

				this.dispatchEvent({
					type: "LayerChange",
					old: old,
					new: layer
				});
			}
		}

		this.save = function() {

		}

		this.load = function() {

		}
	});




	ChipLayer = Logic.class.ChipLayer = ELATE.create("ChipLayer", function() {
		this.implements("EventDispatcher");
		this.implements("Saveable");
		this.implements("Treeable");

		this.build = function(chipsWide, chipsTall, rawFile) {
			this.super.Treeable("map");

			if(rawFile) {
				this.chips = Logic.unpackageMap(rawFile);

				this.chipsWide = this.chips[0].length;
				this.chipsTall = this.chips.length;

				this.chipSetNames = ["chipset01.png"];
			}

			else {
				this.chipsWide = chipsWide || 16;
				this.chipsTall = chipsTall || 16;

				this.chips = [];
				this.chipSetNames = [];

				for(var h = 0; h < this.chipsTall; h++) {
					this.chips[h] = [];

					for(var w = 0; w < this.chipsWide; w++) {
						this.chips[h][w] = -1;			
					}
				}
			}

			return {Saveable: ["somePath", true]};
		}



		this.getChip = function(row, col) {
			return this.chips[row][col];
		};

		this.setChip = function(row, col, value) {	
			var oldVal = this.chips[row][col]

			if(oldVal != value) {
				this.chips[row][col] = value;
				this.markUnsaved();
			}
		};

		


		this.ejectModifications = function() {
			var out = this.modifications;
			this.modifications = [];
			return out;
		}

		this.save = function() {
			var out = {};
			out.chips = ""
			for(var row = 0; row < this.chipsTall; row++) {
				for(var col = 0; col < this.chipsWide; col++) {
					out.chips += this.chips[row][col] + " ";
				}

				if(row < height-1)
					out.chips += "\n";
			}

			out.chipSetNames = this.chipSetNames;

			BRIDGE.saveFile(this.filePath, JSON.stringify(out));
			
		}


		this.load = function() {

		}
	})




	PINE.signalNeedReady("LogicalResources");
})




</script>