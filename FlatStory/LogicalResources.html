<script type="text/javascript">


// var Resources, Visuals, ChipLayer;

var Logic, ChipLayer;

PINE.waitForNeeds(["Resources", "ELATE"], function() {
	Logic = FLAT.Resources.Logic = {}


	Logic.openProject = function(projectName){

		var projectFile = Resources.projects[projectName];

		if(projectFile != undefined) {
			Resources.currentProject = projectFile;
			return new SyncPromise.resolved(projectFile);
			
		}
		else {
			projectFile = new Logic.class.UnloadedProject(projectName);
			Resources.currentProject = projectFile;

			var filePath = projectFile.pathPrefix + projectName+".flat-project.txt";

			return Resources.fileTree.openJSON(filePath)
			.then(function(response){

				projectFile.filePath = response.dirItem;
				response.dirItem.saveable = projectFile;

				ELATE.evolve(projectFile, "Project", [null, response.data]);
				return projectFile.projectReadyPromise;
			})
			.then(function(){ return projectFile; });	

			// return BRIDGE.loadJSON(filePath).then(function(projectData){
			// 	ELATE.evolve(projectFile, "Project", [null, projectData]);
			// 	return projectFile.projectReadyPromise;
			// })
			// .then(function(){ return projectFile; });		
		}

	}





	Logic.unpackageMap = function(mapFile) {
		var out = mapFile.split(/\n/g);

		for(var i in out) {
			out[i] = out[i].match(/\S+/g);
		}

		return out;
	}

	Logic.packageMap = function(chips) {
		var printOut = ""
		for(var row = 0; row < height; row++) {
			for(var col = 0; col < width; col++) {
				printOut += chips[row][col] + " ";
			}

			if(row < height-1)
				printOut += "\n";
		}
		return printOut;
	}





	Logic.class = {}


	Logic.class.UnloadedProject = ELATE.create("UnloadedProject", function() {
		this.build = function(projectName) {
			this.pathPrefix = FLAT.BridgePrefix + projectName+"/";
			this.projectName = projectName;
		}
	});


	Project = Logic.class.Project = ELATE.create("Project", function() {
		this.evolvesFrom("UnloadedProject");
		this.implements("Treeable");

		this.parseArgs = function(name, projectData) {
			return {
				UnloadedProject : [name],
				Project: [projectData]
			}
		}

		this.evolveThis = function(projectData) {
			var THIS = this;
			THIS.super.Treeable(null, "maps");

			var mapPath = projectData.currentMap;
			var mapName = mapPath.match(/[^\/]+$/);
			var mapPath = Resources.currentProject.pathPrefix+"maps/"+mapName+"/"
			mapFilePath = mapPath+mapName+".map-file.txt";


			THIS.projectReadyPromise = Resources.fileTree.openJSON(mapFilePath)
			.then(function(response){
				var mapData = response.data;

				THIS.currentMap = new FlatMap(mapPath, mapData);
				THIS.currentMap.dirItem = response.dirItem;
				response.dirItem.saveable = THIS.currentMap;

				THIS.appendChild(THIS.currentMap);
				return THIS.currentMap.flatMapReadyPromise;
			});
		}
	});



	FlatMap = Logic.class.FlatMap = ELATE.create("FlatMap", function() {


		this.implements("EventDispatcher");
		this.implements("Saveable");
		this.implements("Treeable");

		this.build = function(mapPath, mapData) {
			// this.layers = [];
			var THIS = this;

			THIS.super.Treeable("project", "layers");


			THIS.chipsWide = mapData.chipsWide;
			THIS.chipsTall = mapData.chipsTall;
			THIS.mapPath = mapPath;
			THIS.width = THIS.chipsWide * 16;  //TODO magic number, and move chipwidth to layers
			THIS.height = THIS.chipsTall * 16;

			var layerPromises = [];

			for(var i = 0; i < mapData.layers.length; i++) {
				var layerName = mapData.layers[i];
				var layerPath = THIS.mapPath+layerName;

				var promise = Resources.fileTree.openJSON(layerPath)
				.then(function(response){
					var addMe = new ChipLayer(null, null, response.data);
					addMe.dirItem = response.dirItem;
					response.dirItem.saveable = addMe;

					THIS.addLayer(addMe);
					THIS.repeatDispatches(addMe);
				});


				layerPromises.push(promise);
			}




			THIS.flatMapReadyPromise = SyncPromise.all(layerPromises).then(function(){
				THIS.currentLayer = THIS.layers[mapData.currentLayer || 0];
			});

			return {Saveable: [mapPath, true]};
		}

		this.addLayer = function(layer) {
			// if(layer.map != this)

			if(this.appendChild(layer))
				this.repeatDispatches(layer);
			
		}


		this.createNewLayer = function(name, chipsWide, chipsTall) {
			var addMe = new ChipLayer(chipsWide || 16, chipsTall || 16);
			this.addLayer(addMe);
			this.markUnsaved();

			return addMe;
		}


		this.setCurrentLayer = function(layer) {
			if(layer && this.layers.indexOf(layer) == -1)
				PINE.err("Can not set current layer to layer from another map");

			else if (this.currentLayer != layer){
				var old = this.currentLayer;
				this.currentLayer = layer;	

				this.dispatchEvent({
					type: "LayerChange",
					old: old,
					new: layer
				});
			}
		}

		this.toLoadable = function() {
			var out = {};
			out.layers = [];
			for(var i = 0; i < this.layers.length; i++) {
				out.layers.push(this.layers[i].dirItem.name);
			}
			out.chipsWide = this.chipsWide;
			out.chipsTall = this.chipsTall;
			return JSON.stringify(out);
		}

		this.load = function() {

		}
	});




	ChipLayer = Logic.class.ChipLayer = ELATE.create("ChipLayer", function() {
		this.implements("EventDispatcher");
		this.implements("Saveable");
		this.implements("Treeable");

		this.build = function(chipsWide, chipsTall, rawFile) {
			this.super.Treeable("map");

			if(rawFile) {
				this.chips = Logic.unpackageMap(rawFile.chips);

				this.chipsWide = this.chips[0].length;
				this.chipsTall = this.chips.length;

				this.chipSetNames = rawFile.chipSetNames;
			}

			else {
				this.chipsWide = chipsWide || 16;
				this.chipsTall = chipsTall || 16;

				this.chips = [];
				this.chipSetNames = ["chipset01.png"];

				for(var h = 0; h < this.chipsTall; h++) {
					this.chips[h] = [];

					for(var w = 0; w < this.chipsWide; w++) {
						this.chips[h][w] = -1;			
					}
				}
			}

			return {Saveable: ["somePath", true]};
		}



		this.getChip = function(row, col) {
			return this.chips[row][col];
		};

		this.setChip = function(row, col, value) {	
			var oldVal = this.chips[row][col]

			if(oldVal != value) {
				this.chips[row][col] = value;
				this.markUnsaved();
			}
		};

		


		// this.ejectModifications = function() {
		// 	var out = this.modifications;
		// 	this.modifications = [];
		// 	return out;
		// }


		this.makeCurrentLayer = function() {
			this.map.setCurrentLayer(this);
		}

		this.toLoadable = function() {
			var out = {};
			out.chips = ""
			for(var row = 0; row < this.chipsTall; row++) {
				for(var col = 0; col < this.chipsWide; col++) {
					out.chips += this.chips[row][col] + " ";
				}

				if(row < this.chipsTall-1)
					out.chips += "\n";
			}

			out.chipSetNames = this.chipSetNames;
			return JSON.stringify(out);
			// BRIDGE.saveFile(this.filePath, JSON.stringify(out));
			
		}	


		this.load = function() {

		}
	})




	PINE.signalNeedReady("LogicalResources");
})




</script>