<script type="text/javascript">




PINE.waitForNeed("FILE_BRIDGE", function() {

	var BYTE_SIZES = [];
	BYTE_SIZES.push(["kb", 1000]);
	BYTE_SIZES.push(["MB", 1000*1000]);
	BYTE_SIZES.push(["Gb", 1000*1000*1000]);
	BYTE_SIZES.push(["Tb", 1000*1000*1000*1000]);

	PINE.createNeedle("[filebrowser]", function() {
		this.addAttArg("styleTemplate", ["filebrowser"], "string", "oneDirNamesSizes");
		this.addAttArg("path", ["filebrowserPath", "filepath"], "string", "UNSET");
		this.addAttArg("showExtension", ["filebrowserShowExtension", "showExtension"], "boolean", true);
		this.addAttArg("fileTree", ["filebrowserVirtualTree", "filebrowserTree", "fileTree"], "pvar");

		this.addOp(function(state) {
			var path = state.getArg("path");
			state.currentPath = "";

			state.beforeDisplayListeners = [];

			var template = El.byID(state.getArg("styleTemplate"));

			if(template.tagName == "SINGLEDIRBROWSER") {
				// var template = El.byID("singleDirBrowserTemplate");
				var addMe = state.spawner = template.cloneNode(true);
				addMe.id = "";

				PINE.updateAt(addMe);

				// addMe.FNS.onSelectionChange(console.log);

				state.domNode.appendChild(addMe);

				addMe.addEventListener("dblclick", function(event) {



					var dirItemNode = event.target.parentNode;
					var setPath;

					console.log(event);

					
					if(dirItemNode.classList.contains("parentFolder")) {
							//
						if(state.currentPath.length > 0 && !state.currentPath.endsWith("../"))
							setPath = state.currentPath.replace(/[^\/]+\/?$/, "");
						
						else 
							setPath = state.currentPath + "../";
					}

					else {
						var dirItem = El.pvar(dirItemNode, "item");

						if(dirItem.isDir) { 

							if(state.currentPath.startsWith("../"))
								setPath = state.currentPath+dirItem.name;

							else	
								setPath = dirItem.name;
						}
					}

					if(setPath !== undefined)
						state.domNode.FNS.setFilepath(setPath);
				});
			}

			if(state.getArg("fileTree"))
				this.FNS.setFileTree(state.getArg("fileTree"));

			state.domNode.FNS.setFilepath(state.getArg("path"));
		});



		this.FNS.setFileTree = function(fileTree) {
			console.log(fileTree);
			this.fileTree = fileTree;
			this.FNS.updateFileListing();
		}

		this.FNS.updateFileListing = function() {
			var state = this;
			state.fileTree.ls().then(function(items) {
					//
				state.domNode.PVARS.directoryList = items;

				// for(var i = 0; i < items.length; i++) {
				// 	var item = items[i];
				// 	// var bytes = parseInt(items[i].size);
				// 	// var roundedSize;

				// 	// for(var b = 0; b < BYTE_SIZES.length && !roundedSize; b++) {
				// 	// 	var size = BYTE_SIZES[b];

				// 	// 	if(bytes > size[1]) {
				// 	// 		roundedSize = (bytes/(size[1] * 1.0)).toFixed(1) + " "+size[0];
				// 	// 	}
				// 	// }

				// 	// item.size = roundedSize || item.size+" b";


				// 	item.extension = item.name.match(/\..*/);
				// 	if(item.extension) {
				// 		item.extension = item.extension[0];

				// 		if(item.extension.length) {
				// 			console.log(state.getArg("showExtension"));

				// 			if(state.getArg("showExtension") == false)
				// 				item.name = item.name.replace(item.extension, '');

				// 			item.extension = item.extension.slice(1);
				// 		}
				// 	}
				// 	else
				// 		item.extension = "";
				// }

				var listeners = state.beforeDisplayListeners;
				for(var i = 0; i < listeners.length; i++)
					listeners[i](items);

				state.spawner.FNS.spawnerUpdate();
			});
		}


		this.FNS.setFilepath = function(filePath) {
			var state = this;
			var domNode = state.domNode;

			if(filePath != "UNSET") {
					//

				console.log("SET PATH", filePath)

				if(state.fileTree == undefined) {
					state.fileTree = new BRIDGE.virtualFileTree(filePath);
					state.fileTree.ready.then(state.FNS.updateFileListing);
				}
				else {
					state.fileTree.cd("/"+filePath)
					.then(state.FNS.updateFileListing);;
				}

				console.log(state.fileTree);

				// if(filePath.length && filePath.endsWith("/") == false)
				// filePath += "/";



				// BRIDGE.getDirectory(filePath).then(function(request) {
				// 	state.currentPath = filePath;
				// 	var items = domNode.PVARS.directoryList = JSON.parse(request.response);

				// 	for(var i = 0; i < items.length; i++) {
				// 		var item = items[i];
				// 		item.name = item.name.replace(filePath, "");
				// 		item.isDir = item.isDir == "True";

				// 		var bytes = parseInt(items[i].size);
				// 		var roundedSize;

				// 		for(var b = 0; b < BYTE_SIZES.length && !roundedSize; b++) {
				// 			var size = BYTE_SIZES[b];

				// 			if(bytes > size[1]) {
				// 				roundedSize = (bytes/(size[1] * 1.0)).toFixed(1) + " "+size[0];
				// 			}
				// 		}

				// 		item.size = roundedSize || item.size+" b";


				// 		item.extension = item.name.match(/\..*/);
				// 		if(item.extension) {
				// 			item.extension = item.extension[0];

				// 			if(item.extension.length) {
				// 				console.log(state.getArg("showExtension"));

				// 				if(state.getArg("showExtension") == false)
				// 					item.name = item.name.replace(item.extension, '');

				// 				item.extension = item.extension.slice(1);
				// 			}
				// 		}
				// 		else
				// 			item.extension = "";

						
				// 	}

				// 	var listeners = state.beforeDisplayListeners;
				// 	for(var i = 0; i < listeners.length; i++)
				// 		listeners[i](items);

				// 	state.spawner.FNS.spawnerUpdate();
				// });
			}

			else {
				domNode.PVARS.directoryList = [];
				state.spawner.FNS.spawnerUpdate();
			}
		}


		this.FNS.beforeDisplay = function(fn) {
			this.beforeDisplayListeners.push(fn);
		}


	});


	

});
	
</script>



<style easyStyleVar>
*[fileBrowser] {
	--fileBrowserBorderWidth: 1px;
	--fileBrowserBorderColor: rgba(0,0,0,0.1);
	--fileBrowserTableLableBg: rgba(0,0,0,0.5);
	--fileBrowserSelectedItem: rgba(20,20,20, 0.3);
}

</style>



<style>
/*dirItem {
	display: block;
	border-bottom: 1px solid black;
}*/






singleDirBrowser {
	display: table;
	width: 100%;
}

	singleDirBrowser > dirItem, singleDirBrowser > dirTableHeader{
		display: table-row;
	}
		singleDirBrowser > dirTableHeader {
			background-color: var(--fileBrowserTableLableBg);
			border-width: var(--fileBrowserBorderWidth);
			border-color: var(--fileBrowserBorderColor);
			border-bottom-style: solid;
		}

		singleDirBrowser > dirItem > *,
		singleDirBrowser > dirTableHeader > * {
			display: table-cell;
			padding-left: 6px;
			padding-right: 6px;
			user-select: none;
			-moz-user-select: none;
		}

			singleDirBrowser > dirItem > name.isDir {
				background-image: 
      			url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='50' height='50' viewBox='0 0 50 50'><polygon fill='none' stroke='lightblue' stroke-width='6' points='2,48 2,15 5,15 10,2 30,2 35,15 48,15 48,48'/></svg>");
      			background-size: contain;
      			background-repeat: no-repeat;
			}

				singleDirBrowser > #parentFolder > name {
					padding-left: 25px;
				}

					singleDirBrowser > #parentFolder > name {
						background-position: 4px;
					}

				

				singleDirBrowser > dirItem > name {
					padding-left: 15px;
				}

					singleDirBrowser > dirItem > name.isDir {
						padding-left: 35px;
						background-position: 15px;
					}

			singleDirBrowser > dirItem.list_selected {
				background-color: var(--fileBrowserSelectedItem);
			}

			singleDirBrowser > dirItem > *:not(:first-child) {
				border-left-style: solid;
				border-color: var(--fileBrowserBorderColor);
				border-width: var(--fileBrowserBorderWidth);
			}
</style>



<noDisplay style="display: none" nopine>

	<singleDirBrowser id="oneDirNamesSizes" spawner="directoryList" selectableList=">dirItem">
		<dirTableHeader><name class="isDir">Filename</name><size>Size</size></dirTableHeader>
		<dirItem class="parentFolder"><name class="isDir">Parent Folder</name><size></size></dirItem>
		<dirItem spawn pvars="item=directoryList[i]"><name class="{{? item.isDir: 'isDir'}}">{{item.name}}</name><size>{{item.size}}</size></dirItem>
	</singleDirBrowser>





	<singleDirBrowser id="oneDirNames" spawner="directoryList" selectableList=">dirItem">
		<!-- <dirTableHeader><name class="isDir">Filename</name><size>Size</size></dirTableHeader> -->
		<dirItem class="parentFolder"><name class="isDir">Parent Folder</name></dirItem>
		<dirItem spawn pvars="item=directoryList[i]"><name class="{{? item.isDir: 'isDir'}}">{{item.name}}</name></dirItem>
	</singleDirBrowser>
	
</noDisplay>